
#include "meshplus.h"

Meshplus::Meshplus() : ParMesh() {}

Meshplus::Meshplus(ParMesh *pmesh_) : ParMesh(*pmesh_) {}

void Meshplus::PrintVTK_eta(std::ostream &out, Vector &other_attri) {
  out << "# vtk DataFile Version 3.0\n"
         "Generated by MFEM\n"
         "ASCII\n"
         "DATASET UNSTRUCTURED_GRID\n";

  if (Nodes == NULL) {
    out << "POINTS " << NumOfVertices << " double\n";
    for (int i = 0; i < NumOfVertices; i++) {
      out << vertices[i](0);
      int j;
      for (j = 1; j < spaceDim; j++) {
        out << ' ' << vertices[i](j);
      }
      for (; j < 3; j++) {
        out << ' ' << 0.0;
      }
      out << '\n';
    }
  } else {
    Array<int> vdofs(3);
    out << "POINTS " << Nodes->FESpace()->GetNDofs() << " double\n";
    for (int i = 0; i < Nodes->FESpace()->GetNDofs(); i++) {
      vdofs.SetSize(1);
      vdofs[0] = i;
      Nodes->FESpace()->DofsToVDofs(vdofs);
      out << (*Nodes)(vdofs[0]);
      int j;
      for (j = 1; j < spaceDim; j++) {
        out << ' ' << (*Nodes)(vdofs[j]);
      }
      for (; j < 3; j++) {
        out << ' ' << 0.0;
      }
      out << '\n';
    }
  }

  int order = -1;
  if (Nodes == NULL) {
    int size = 0;
    for (int i = 0; i < NumOfElements; i++) {
      size += elements[i]->GetNVertices() + 1;
    }
    out << "CELLS " << NumOfElements << ' ' << size << '\n';
    for (int i = 0; i < NumOfElements; i++) {
      const int *v = elements[i]->GetVertices();
      const int nv = elements[i]->GetNVertices();
      out << nv;
      for (int j = 0; j < nv; j++) {
        out << ' ' << v[j];
      }
      out << '\n';
    }
    order = 1;
  } else {
    Array<int> dofs;
    int size = 0;
    for (int i = 0; i < NumOfElements; i++) {
      Nodes->FESpace()->GetElementDofs(i, dofs);
      MFEM_ASSERT(Dim != 0 || dofs.Size() == 1,
                  "Point meshes should have a single dof per element");
      size += dofs.Size() + 1;
    }
    out << "CELLS " << NumOfElements << ' ' << size << '\n';
    const char *fec_name = Nodes->FESpace()->FEColl()->Name();

    if (!strcmp(fec_name, "Linear") || !strcmp(fec_name, "H1_0D_P1") ||
        !strcmp(fec_name, "H1_1D_P1") || !strcmp(fec_name, "H1_2D_P1") ||
        !strcmp(fec_name, "H1_3D_P1")) {
      order = 1;
    } else if (!strcmp(fec_name, "Quadratic") ||
               !strcmp(fec_name, "H1_1D_P2") || !strcmp(fec_name, "H1_2D_P2") ||
               !strcmp(fec_name, "H1_3D_P2")) {
      order = 2;
    }
    if (order == -1) {
      mfem::err << "Mesh::PrintVTK : can not save '" << fec_name
                << "' elements!" << std::endl;
      mfem_error();
    }
    for (int i = 0; i < NumOfElements; i++) {
      Nodes->FESpace()->GetElementDofs(i, dofs);
      out << dofs.Size();
      if (order == 1) {
        for (int j = 0; j < dofs.Size(); j++) {
          out << ' ' << dofs[j];
        }
      } else if (order == 2) {
        const int *vtk_mfem;
        switch (elements[i]->GetGeometryType()) {
        case Geometry::SEGMENT:
        case Geometry::TRIANGLE:
        case Geometry::SQUARE:
          vtk_mfem = vtk_quadratic_hex;
          break; // identity map
        case Geometry::TETRAHEDRON:
          vtk_mfem = vtk_quadratic_tet;
          break;
        case Geometry::PRISM:
          vtk_mfem = vtk_quadratic_wedge;
          break;
        case Geometry::CUBE:
        default:
          vtk_mfem = vtk_quadratic_hex;
          break;
        }
        for (int j = 0; j < dofs.Size(); j++) {
          out << ' ' << dofs[vtk_mfem[j]];
        }
      }
      out << '\n';
    }
  }

  out << "CELL_TYPES " << NumOfElements << '\n';
  for (int i = 0; i < NumOfElements; i++) {
    int vtk_cell_type = 5;
    Geometry::Type geom_type = GetElement(i)->GetGeometryType();
    if (order == 1) {
      switch (geom_type) {
      case Geometry::POINT:
        vtk_cell_type = 1;
        break;
      case Geometry::SEGMENT:
        vtk_cell_type = 3;
        break;
      case Geometry::TRIANGLE:
        vtk_cell_type = 5;
        break;
      case Geometry::SQUARE:
        vtk_cell_type = 9;
        break;
      case Geometry::TETRAHEDRON:
        vtk_cell_type = 10;
        break;
      case Geometry::CUBE:
        vtk_cell_type = 12;
        break;
      case Geometry::PRISM:
        vtk_cell_type = 13;
        break;
      default:
        break;
      }
    } else if (order == 2) {
      switch (geom_type) {
      case Geometry::SEGMENT:
        vtk_cell_type = 21;
        break;
      case Geometry::TRIANGLE:
        vtk_cell_type = 22;
        break;
      case Geometry::SQUARE:
        vtk_cell_type = 28;
        break;
      case Geometry::TETRAHEDRON:
        vtk_cell_type = 24;
        break;
      case Geometry::CUBE:
        vtk_cell_type = 29;
        break;
      case Geometry::PRISM:
        vtk_cell_type = 32;
        break;
      default:
        break;
      }
    }

    out << vtk_cell_type << '\n';
  }

  // write attributes
  out << "CELL_DATA " << NumOfElements << '\n'
      << "SCALARS cell_scalars double\n"
      << "LOOKUP_TABLE default\n";
  for (int i = 0; i < NumOfElements; i++) {
    out << other_attri[i] << '\n';
  }
  out.flush();
}
